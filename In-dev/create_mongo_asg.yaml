version: '2.0'

nibiru.create_mongo_asg:
  description: A Generic workflow that creates an asg in AWS.
  type: direct
  output: 
    lc_name: <% $.lc_name %>
    asg_name: <% $.asg_name %>
    status_message: <% $.status_message %>

  input:
    - Asg_name
    - Environment
    - App_id
    - LaunchConfigurationName
    - MinSize
    - MaxSize
    - DesiredCapacity
    - Team_id
    - ImageId
    - EbsOptimized
    - InstanceType
    - VolumeSize
    - VolumeType
    - StorageType
    - Role 
    - t_owner_individual
    - KeyName
    - Assume_role
    - consul_endpoint

  vars:
    UserData: |
              #!/bin/bash  
              cd /root && git clone https://github.com/Susanthab/my_projects.git mongo
              chmod +x ./mongo/aws/userdata_lc_privateIp.sh
              ./mongo/aws/userdata_lc_privateIp.sh

              #!/bin/sh
              #cloud-config
              output: {all: '| tee -a /var/log/cloud-init-output.log'}
              set -x

              sleep 5

              echo "Pragramatically mount block device at EC2 startup..."
              # http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-using-volumes.html
              # The following code is only to add one device. 
              cp /etc/fstab /etc/fstab.orig
              umd=`lsblk --noheadings --raw | grep -v "/" | grep -v "xvda\|sda1" | awk '{print "/dev/"$1}'`
              mkfs -t ext4 $umd
              mkdir /data
              mount $umd /data
              UUID=`blkid | grep $umd | awk -F'UUID="' '{print $2}' | awk -F'"' '{print $1}'`
              echo "UUID=$UUID       /data   ext4    defaults,nofail        0       2" >> /etc/fstab
              mount -a

              sleep 5

              pip install -q -r ./mongo/ansible-roles/requirements.txt
              ansible-playbook -i "localhost," -c local /root/mongo/ansible-roles/test_install_mongo.yaml

              sleep 10

              # Use below script is to initialize the replica set in ASG. 
              wget http://s3.amazonaws.com/ec2metadata/ec2-metadata
              sudo chmod u+x ec2-metadata
              EC2_AVAIL_ZONE=$(./ec2-metadata -z | grep -Po "(us|sa|eu|ap)-(north|south|central)?(east|west)?-[0-9]+")
              EC2_REGION="`echo \"$EC2_AVAIL_ZONE\" | sed -e 's:\([0-9][0-9]*\)[a-z]*\$:\\1:'`"
              INSTANCE_ID=$(./ec2-metadata | grep instance-id | awk 'NR==1{print $2}')
              CURRENT_NODE_IP=$(aws ec2 describe-instances --instance-ids ${INSTANCE_ID} --region ${EC2_REGION} --query Reservations[].Instances[].PrivateIpAddress --output text)
              AG_NAME=$(aws autoscaling describe-auto-scaling-instances --instance-ids ${INSTANCE_ID} --region ${EC2_REGION} --query AutoScalingInstances[].AutoScalingGroupName --output text)
              SECONDARY="false"
              for ID in $(aws autoscaling describe-auto-scaling-groups --auto-scaling-group-names ${AG_NAME} --region ${EC2_REGION} --query AutoScalingGroups[].Instances[].InstanceId --output text);
              do
                IP=$(aws ec2 describe-instances --instance-ids $ID --region ${EC2_REGION} --query Reservations[].Instances[].PrivateIpAddress --output text)
                echo "Checking for the Primary node IP."
                P=`/usr/bin/mongo ${IP}:27017 --eval "printjson(rs.isMaster())" | grep "primary" | cut -d"\"" -f4`
                if [ -n "$P" ]; then
                    echo "Primary node found, record the PRIMARY node IP"
                    PRIMARY=${P}
                    echo $PRIMARY
                fi
                IS_SECONDARY=`/usr/bin/mongo ${IP}:27017 --eval "printjson(db.isMaster().secondary)" | grep true`
                if [ "$IS_SECONDARY" = "true" ]; then
                  SECONDARY="true"
                fi
              done
              # check if the PRIMARY node exists
              if [ -n "$PRIMARY" ]; then
                  echo "Primary node exists."
                  echo "checking un-healthy nodes and remove it from the replica set."
                  UH=`/usr/bin/mongo ${PRIMARY}/admin --eval "printjson(rs.status())" | grep --before-context=5 "not reachable/healthy" | grep "name" | cut -d"\"" -f4 | head -n 1`
                  while [ -n "$UH" ]; do
                      echo "Un-healthy node exists, removing the node."
                      echo $UH
                      R=`/usr/bin/mongo ${PRIMARY}/admin --eval "printjson(rs.remove('${UH}'))"`
                      echo $R
                      UH=`/usr/bin/mongo ${PRIMARY}/admin --eval "printjson(rs.status())" | grep --before-context=5 "not reachable/healthy" | grep "name" | cut -d"\"" -f4 | head -n 1`
                  done
                  echo "Join the new secondary to the existing replica set."
                  R=`/usr/bin/mongo ${PRIMARY}/admin --eval "printjson(rs.add('${CURRENT_NODE_IP}:27017'))"`
                  echo $R
              elif [ "$SECONDARY" = "false" ]; then
                  # Initialize replica set
                  echo "No primary, initialize the replica set."
                  R=`/usr/bin/mongo ${CURRENT_NODE_IP}/admin --eval "printjson(rs.initiate())"`
                  echo $R
              else
                echo "MongoDB Replica set has lost the Quorum. Please fix it manually."
              fi

  tasks:

    assume_role:
      action: boto3.assume_role
      input:
        role_arn: <% $.Assume_role %>
      publish:
        credentials: <% task(assume_role).result.result %>
      on-success:
          - get_vpc_configuration

    get_vpc_configuration:
      action: nibiru.get_consul_json
      publish:
        vpc_config: <% task(get_vpc_configuration).result.result %>
      input:
        consul_endpoint: <% $.consul_endpoint %>
      on-success:
        - get_vpc_config_values

    get_vpc_config_values:
      action: std.noop
      publish:
        security_group_id: <% $.vpc_config.security_groups['0'] %>
        iam_role_mongo: <% $.vpc_config.iam.roles.mongo['name'] %>
        subnets: <% $.vpc_config.subnets.values().join(",") %>
        region: <% $.vpc_config.region %>
        is_lc_exists: <% $.vpc_config.database.mongo.autoscaling.launch_config.containsKey($.LaunchConfigurationName) %>
        is_asg_exists: <% $.vpc_config.database.mongo.autoscaling.asg_config.containsKey($.Asg_name) %>
        status_message: "Get only specific values needed for this workflow from vpc config."
      on-success:
        - notify
        - check_lc

    check_lc:
      action: boto3.action
      input:
        region: <% $.region %>
        service: autoscaling
        action_name: describe_launch_configurations
        params: <% dict(LaunchConfigurationNames => list($.LaunchConfigurationName) ) %>
        credentials: <% $.credentials %>
      publish:
        status_message: "Retrieve Launch Configuration data." 
      on-success:
        - notify
        - check_lc_result_json

    check_lc_result_json:
      action: nibiru.json_loads
      input:
        value: <% str(task(check_lc).result.result) %>
      publish:
        lc_name: <% task(check_lc_result_json).result.result.LaunchConfigurations %>
        status_message: "Check the existence of the Launch Configuration."
      on-success:
        - notify
        - check_asg: <% len($.lc_name)!=0 %>
        - select_storage_type: <% len($.lc_name)=0 %>

    select_storage_type:
      action: core.local
      input: 
        cmd: "printf <% $.StorageType %>"
      publish: 
        path: <% task(select_storage_type).result.stdout %>
        status_message: "Security Group exists. Selecting storage type between EBS and Ephemeral."
      on-success:
        - notify
        - create_launch_configuration_EBS: <% $.path = 'EBS' %>
        - create_launch_configuration_Ephemeral: <% $.path = 'Ephemeral' %>

    create_launch_configuration_EBS:
      action: boto3.action
      input:
        region: <% $.region %>
        service: autoscaling
        action_name: create_launch_configuration
        params: <% dict(LaunchConfigurationName => $.LaunchConfigurationName , ImageId => $.ImageId, InstanceType => $.InstanceType, KeyName => $.KeyName, SecurityGroups => list($.security_group_id), IamInstanceProfile => $.iam_role_mongo, UserData => $.UserData, BlockDeviceMappings => list(dict(DeviceName => "/dev/sdg", Ebs => dict(VolumeSize => $.VolumeSize, VolumeType => $.VolumeType )))) %>
        credentials: <% $.credentials %>
      publish:
        status_message: "Create Launch Configuration with EBS as storage type."
      on-success: 
        - notify
        - check_asg
        - save_launch_config_meta_data

    create_launch_configuration_Ephemeral:
      action: boto3.action
      input:
        region: <% $.region %>
        service: autoscaling
        action_name: create_launch_configuration
        params: <% dict(LaunchConfigurationName => $.LaunchConfigurationName , ImageId => $.ImageId, InstanceType => $.InstanceType, KeyName => $.KeyName, SecurityGroups => list($.security_group_id), IamInstanceProfile => $.iam_role_mongo, UserData => $.UserData, BlockDeviceMappings => list(dict(DeviceName => "/dev/sdc", VirtualName => "ephemeral1" ))) %>
      publish:
        status_message: "Create Launch Configuration with Ephemeral as storage type."
      on-success:
        - notify
        - check_asg
        - save_launch_config_meta_data

    save_launch_config_meta_data:
      action: consul.put
      input:
        key: <% $.consul_endpoint %>database/mongo/autoscaling/launch_config/<% $.LaunchConfigurationName %>/name
        value: <% $.LaunchConfigurationName %>

    check_asg:
      action: boto3.action
      input:
        region: <% $.region %>
        service: autoscaling
        action_name: describe_auto_scaling_groups
        params: <% dict(AutoScalingGroupNames => list($.Asg_name) ) %>
        credentials: <% $.credentials %>
      publish:
        status_message: "Retrieve Auto-scaling Group data."
      on-success:
        - notify
        - check_asg_result_json

    check_asg_result_json:
      action: nibiru.json_loads
      input:
        value: <% str(task(check_asg).result.result) %>
      publish:
        asg_name: <% task(check_asg_result_json).result.result.AutoScalingGroups %> 
        asg: <% task(check_asg_result_json).result.result.AutoScalingGroups %>       
        status_message: "Check the existence of the Auto-scaling Group."
      on-success:
        - notify
        - create_auto_scaling_group: <% len($.asg_name)=0 %>

    create_auto_scaling_group:
      action: boto3.action
      input:
        region: <% $.region %>
        service: autoscaling
        action_name: create_auto_scaling_group
        params: <% dict(LaunchConfigurationName => $.LaunchConfigurationName, AutoScalingGroupName => $.Asg_name, MinSize => $.MinSize, MaxSize => $.MaxSize, DesiredCapacity => $.DesiredCapacity, VPCZoneIdentifier => $.subnets, Tags => list(dict(Key => "Project", Value => "Nibiru-V3"), dict(Key => "t_environment", Value => $.Environment), dict(Key => "app_id", Value => str($.App_id)), dict(Key => "team_id", Value => $.Team_id), dict(Key => "t_role", Value => $.Role), dict(Key => "t_owner_individual", Value => $.t_owner_individual), dict(Key => "Name", Value => $.Environment + "-" + $.Team_id + "-" + $.Role + "-" + str($.App_id)) )) %>
        credentials: <% $.credentials %>
      publish:
        status_message: "Creating Auto-scaling Group."
      on-success:
        - notify
        - save_asg_config_meta_data

    save_asg_config_meta_data:
      action: consul.put
      input:
        key: <% $.consul_endpoint %>database/mongo/autoscaling/asg_config/<% $.Asg_name %>/name
        value: <% $.Asg_name %>
      publish:
        status_message: "Saving asg name to Consul."
      on-success:
        - notify
        - check_asg2

    check_asg2:
      action: boto3.action
      input:
        region: <% $.region %>
        service: autoscaling
        action_name: describe_auto_scaling_groups
        params: <% dict(AutoScalingGroupNames => list($.Asg_name) ) %>
        credentials: <% $.credentials %>
      publish:
        status_message: "Retrieve Auto-scaling Group data after creating it."
      on-success:
        - notify
        - check_asg_result_json2

    check_asg_result_json2:
      action: nibiru.json_loads
      input:
        value: <% str(task(check_asg2).result.result) %>
      publish:
        instance_ids: <% task(check_asg_result_json2).result.result.AutoScalingGroups[0].Instances.InstanceId %>
        status_message: "Get instances ids."
      on-success:
        - notify
        - describe_instances

    describe_instances:
      action: boto3.action
      input:
        region: <% $.region %>
        service: ec2
        action_name: describe_instances
        params: <% dict(InstanceIds => $.instance_ids) %>
        credentials: <% $.credentials %>
      publish:
        status_message: "Describe instances of the autoscaling group."
      on-success:
        - notify
        - describe_instances_result_json

    describe_instances_result_json:
      action: nibiru.json_loads
      input:
        value: <% str(task(describe_instances).result.result) %>
      publish:
        instance_privateips: <% task(describe_instances_result_json).result.result.Reservations.select($.Instances.PrivateIpAddress).flatten() %>
        status_message: "Describe instances result to json."
      on-success:
        - notify
        - save_instance_data

    save_instance_data:
      with-items: ip in <% range($.instance_privateips.len()) %>
      action: consul.put
      input:
        key: <% $.consul_endpoint %>database/mongo/autoscaling/asg_config/<% $.Asg_name %>/PrivateIpAddress/<% $.ip %>
        value: <% $.instance_privateips[$.ip] %>
      publish:
        status_message: "Save instances Ip addresses in Consul."      
      on-success:
        - notify

    notify:
      action: core.local
      input:
        cmd: "printf '<% $.status_message %>'"